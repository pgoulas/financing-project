Implementation:

The core of the implementation revolves around a while loop that continuously retrieves a specific number of invoices for processing.
 The loop terminates once there are no more unprocessed invoices. To facilitate this, the invoices are initially modified by adding a
 new column that indicates the invoice's processing status. When an invoice is inserted into the database for processing, its status
 is set to PENDING.

The process involves retrieving PENDING invoices, processing them, and updating their status at the end of the process.
The possible statuses are:

CANCELED: The maturity date has passed, and thus there is no need for financing.
 (In real-world scenarios, it's unlikely for an invoice to have this status.)
FINANCED: The invoice has been successfully financed.
NOT_FINANCED: The invoice could not be financed due to a lack of eligible purchasers for the creditor.
SUSPENDED: The invoice contains business errors (e.g., multiple entries for the same creditor on a purchaser)
and requires further investigation.
When an invoice is successfully financed, a new entry is created in the Financing Result table, including the
processed invoice's ID and other relevant financing details.

In the event of a business error, the code will throw the appropriate exception, mark the invoice as SUSPENDED,
 and continue processing the next invoice. For other issues (e.g., database connectivity problems), the error will be
propagated, and the process will stop.


Performance testing:
Due to lack of time, i didn't manage to have results from performance testing. However, below i document some steps, i would follow in order to perform the testing.
1. i would create a script with more data in order to fulfill my db. This script would contain data for already processed invoices, and more purchasers and creditors.
Also, i would add the invoices for processing.  The number of entries for each table would be according to the results you provide me, in order to have a reference for the time calculation.
2, after, i would ensure that my app runs in my local machine as expected and i would report the results.
3. I would try to create through virtual box a vm with the same specs from your example(quad-core x86-64 workstation) and i would try to run the app in there and report the performance results.
4. Probably the use of VirtualVM or JFR could be a good choice to identify the bottlenecks in the code.
5. To optimize the performance behavior, i would probably focus on the creation of indexes in the most common table like invoice as well as in JVM options and the connection polling to callibrate
better the performance behavior.