Implementation:

The core of the implementation revolves around a while loop that continuously retrieves a specific number of invoices for processing.
 The loop terminates once there are no more unprocessed invoices. To facilitate this, the invoices are initially modified by adding a
 new column that indicates the invoice's processing status. When an invoice is inserted into the database for processing, its status
 is set to PENDING.

The process involves retrieving PENDING invoices, processing them, and updating their status at the end of the process.
The possible statuses are:

CANCELED: The maturity date has passed, and thus there is no need for financing.
 (In real-world scenarios, it's unlikely for an invoice to have this status.)
FINANCED: The invoice has been successfully financed.
NOT_FINANCED: The invoice could not be financed due to a lack of eligible purchasers for the creditor.
SUSPENDED: The invoice contains business errors (e.g., multiple entries for the same creditor on a purchaser)
and requires further investigation.
When an invoice is successfully financed, a new entry is created in the Financing Result table, including the
processed invoice's ID and other relevant financing details.

In the event of a business error, the code will throw the appropriate exception, mark the invoice as SUSPENDED,
 and continue processing the next invoice. For other issues (e.g., database connectivity problems), the error will be
propagated, and the process will stop.


Performance Testing:
Due to time constraints, I was unable to obtain results from the performance testing. However, I have documented the steps I would follow to conduct the testing.

1. Data Generation: I would create a script to populate the database with more data, including entries for already processed invoices,
 additional purchasers, and creditors. The script would also add invoices for processing. The number of entries for each table would be
  based on the data you provide, so I could have a reference point for calculating performance.

2. Local Testing: Next, I would ensure that the application runs as expected on my local machine and report the initial performance results.

3. VM Setup: I would then create a virtual machine using VirtualBox, configured with the same specs from your example (quad-core x86-64 workstation).
 I would run the application in the VM and report the performance results.

4. Bottleneck Identification: Tools such as VisualVM or Java Flight Recorder (JFR) could be used to identify bottlenecks in the code.

5. Performance Optimization: To optimize performance, I would focus on creating indexes on the most commonly accessed tables (like the invoice table).
 Additionally, I would fine-tune JVM options and connection pooling to improve overall performance.

